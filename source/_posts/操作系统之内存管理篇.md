title: 操作系统之内存管理篇
date: 2015-01-07 11:18:13
author: 赵空暖
tags: 操作系统
categories: 操作系统
---
程序要运行，必须先加载到内存。但在很久很久以前，准确的说是在操作系统没有出现以前，程序并不需要加载到内存就能运行。实际上，那个时候程序曾经存放在卡片上，计算机每读一张卡片，就运行一条指令。因此，程序是直接从卡片到执行。
![dakong](/image/dakong.png)
图片来源[9千万的差距 百年来数据存储历史回顾](http://tech.sina.com.cn/h/2007-05-17/0723312253.shtml)
但这种从外部存储媒介上直接执行指令的做法效率极低，且灵活性很差。因此人们发明了内存储器来将需要运行的程序先行加载，再自动执行，从而提高效率和灵活性。这也导致了“存储的程序”的概念的出现，此后人们对内存的要求越来越多，越来越高……

继续接着上文，那我们要运行程序要使用内存，那操作系统是如何分配内存的呢。
* 连续内存分配
* 非连续内存分配

##连续内存分配##
* 内存碎片：空闲内存不能被利用
	* 外部碎片:分配单元之间的未被使用内存
	* 内部碎片:分配单元内部的未被使用内存,取决于分配单元大小是否固定
* 动态分配
简单的内存管理方式:当程序被允许进入系统的时候，被分配内存块;分配的内存块在地址上是连续的。
操作系统持续追踪：程序运行中的所有已分配内存块；目前空闲的内存块 Empty-blocks (“holes”)。
	* 首次适配(First-fit)
	![firstfit](/image/firstfit.png)
	要求:
		* 空闲块列表按照地址排序
		* 分配过程需要搜索一个合适的分区
		* 释放分区需要检查其是否可以和临近的空闲分区合并,这样可以得到更大的分区
	* 最佳适配(Best-fit)
	![bestfit](/image/bestfit.png)
	要求：
		* 空闲块列表按照大小排序
		* 分配过程需要查找一个合适的分区
		* 释放分区需要查找并且合并临近的空闲分区（如果找到）
	* 最差适配(Worst-fit)
	![worstfit](/image/worstfit.png)
	要求：
		* 空闲块列表按照尺寸排序
		* 分配非常快(最大的分区)
		* 释放分区需要合并临近的空闲块(如果有)，然后调整空闲块列表

##简单适配策略的比较##
<table><tr><th>适配策略</th><th>优点</th><th>缺点</th></tr><tr><td>首次适配分配机制First Fit Allocation</td><td>简单/在高地址空间有大块的空闲分区</td><td>外部碎片</td></tr><tr><td>最佳适配分配机制Best Fit Allocation</td><td>避免大的空闲块被拆分/减小外部碎片的大小/大部分分配属于尺寸较小的情况下，效果很好</td><td>释放分区较慢/容易产生很多无用的小碎片</td></tr><tr><td>最差适配机制 Worst Fit Allocation</td><td>大部分分配，属于中等尺寸的时候，效果最好</td><td>释放分区较慢/容易破坏大的空闲块，因此后续难以分配大的分区</td></tr></table>
无论采用何种算法都会产生碎片，那么如何减少碎片呢？
##碎片整理##
![pcopy](/image/pcopy.png)
* 碎片整理 – Compaction(压实)
	* 移动拷贝应用程序，把碎片合并起来
	* 需要所有的应用程序可动态重定位
	* 问题
		* 什么时候移动?
		* 开销
* 碎片整理 – Swappingin/out(换入换出)
交换就是将一个进程从内存倒到磁盘上，再将其从磁盘上加载到内存中的过程。
	* 运行中的程序需要更多的内存
	* 抢占等待中的程序，回收它们的内存
	![swap](/image/swap.png)

##非连续内存分配##
* 为什么需要非连续内存分配
因为前面提到的连续内存分配有以下几种缺点，
	* 分配给一个程序的物理内存是连续的
	* 有外碎片、内碎片的问题


非连续分配：优点
* 一个程序的物理地址空间是非连续的
* 更好的内存利用和管理
* 允许共享代码与数据（共享库等…)
* 支持动态加载和动态链接

非连续分配：缺点
* 开销：如何设置虚拟地址和物理地址的转换
	* 软件方案
	* 硬件方案
	两种硬件辅助机制：
		* 分段(segmentation)
		* 分页(paging)

##非连续分配：分段##
程序包含多个段，例如：
* 主程序（main prog）
* 子程序（subroutines）
* 公用库（common libs）
* 栈数据（Stack Data）
* 堆数据（Heap Data）
* 符号表（symbols table）
目的：根据各部分的不同特点，更好的分离和共享
![segmentman](/image/segmentman.png)
分散到多个物理地址空间
![segphy](/image/segphy.png)
分段的逻辑视图
![logicview](/image/logicview.png)
程序访问内存地址需要：一个pair (s, addr)
* s：段号
* addr：段内偏移
![pair](/image/pair.png)
硬件方案：
![phyfangan](/image/phyfangan.png)
段表正是由操作系统建立的。

##非连续分配：分页##
和分段的主要区别是
* 分页是把物理内存分割为大小合适的帧（Frame, Page Frame）
  2的n次方，如512, 4096, 8192
* 把逻辑地址空间也划分为相同大小的页（Page）
  2的n次方，如512, 4096, 8192
* 建立逻辑地址到物理地址的转换机制
	* 页表
	* MMU/TLB

###帧###
物理内存被分割为大小相等的帧。
![zhen](/image/zhen.png)
一个内存物理地址是一个pair(f,o)
f — 帧号(F位, 共有2^F个帧)  frame
o — 帧内偏移(S位,每帧有2^S字节) offsize
物理地址=2^S*f+o
![zhenphyadd](/image/zhenphyadd.png)

物理地址计算的例子
![example](/image/example.png)

###页###
一个程序的逻辑地址空间被划分为大小相等的页。
![pageoffsize](/image/pageoffsize.png)
* 页内偏移的大小= 帧内偏移的大小
* 页号大小<> 帧号大小

一个逻辑地址是一个pair(p,o)
p  — 页号(P 位, 2^P个页)
o  — 页内偏移(S位, 每页有2^S字节)
虚拟地址=2^S*p+o
![pagelogicaddress](/image/pagelogicaddress.png)

* 页寻址机制
![pagefind](/image/pagefind.png)
![pagefind2](/image/pagefind2.png)
* 不是所有的页都有对应的帧，一般是逻辑地址空间大于物理地址空间
* 页是连续的虚拟内存，帧是不连续的物理地址，这样的好处有助于减少碎片。

##页表##
![pagestructs](/image/pagestructs.png)
标志位用来标识此映射关系是否存在、此页被读取过？写过？等等
![pagestruts2](/image/pagestruts2.png)
resident bit 为0 代表没有此对应关系，抛出异常由操作系统处理。
* 分页机制的性能问题
	* 页表可能非常大
		* 64位机器如果每页1024字节，那么一个页表的大小会是多少？ 2^54
		* 每个程序都对应着一个页表，则多个程序要对应多个页表，会多大？
	* 页表变大，cpu cache放不下只能放到内存当中，这样就需要2次内存访问
		* 一次用于获取页表入口
		* 一次用于访问数据
	* 如何处理? 
		* 缓存 （Caching）Translation Look-aside Buffer(TLB)
		* 间接（Indirection）访问 ，类似于索引

###解决之道之一：Translation Look-aside Buffer (TLB)###
缓存近期访问的页帧转换表项
* TLB 使用associative memory(关联内存)实现，具备快速访问性能
* 如果TLB命中，物理页号可以很快被获取
* 如果TLB未命中，对应的表项被更新到TLB中
![cpuTLB](/image/cpuTLB.png)

###解决之道之二：二级/多级页表###
![erjipage](/image/erjipage.png)
* 如此这样，需要三次访问内存，开销增加了，但是好处是一些没有对应关系的行可以不放在页表中了，减少了空间。
推而广之，多级页表如下：
![treepagetable](/image/treepagetable.png)

#问题#
* 分段在内存保护方面有优势，分页在内存利用和优化转移到后备存储方面有优势。
* 分段、分页能否结合？

(图片来源：[清华大学陈瑜老师操作系统公开课](http://www.topu.com/kvideo.php?do=course_progress&kvideoid=4100&classesid=808))