title: 数据交流大通道-内存
date: 2015-04-14 21:03:51
author: 赵空暖
tags: 性能测试
categories: 性能测试
---

#内存条的相关参数#
用鲁大师检测了自己本本的内存信息,好简略
```bash
DIMM 0:	海力士 DDR3 1600MHz 2GB
制造日期	2012 年 02 月
型号	AD HMT325S6CFR8C-PB  N0
序列号	0311CE68
	
DIMM 2:	三星 DDR3 1600MHz 4GB
制造日期	2013 年 06 月
型号	CE Samsung4G1600A9
序列号	20131319
```

#名词解释#
* SDRAM: Synchronous Dynamic Random Access Memory，同步动态随机存储器，同步是指Memory工作需要同步时钟，内部的命令的发送与数据的传输都以它为基准；动态是指存储阵
列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是自由指定地址进行数据读写。
(为什么要刷新？由于动态存储器存储单元存在漏电现象，为了保持每个存储单元数据的正确性，必须保证在64ms内对所有的存储单元刷新一遍。)
* DDR内存：SDRAM在一个时钟周期内只传输一次数据，它是在时钟的上升期进行数据传输；而DDR内存则是一个时钟周期内传输两次数据，它能够在时钟的上升期和下降期各传输一次数据，因此称为双倍速率同步动态随机存储器。DDR内存可以在与SDRAM相同的总线频率下达到更高的数据传输率。

#操作系统与内存#
操作系统是永远绕不过去的，操作系统的主要功能之一就是内存管理。
早期，例如dos直接操作物理内存,风险大,程序简单,规模小.
现在，实际上用户从来没有主导过物理内存的分配（即使有也是极其有限的），具体分配多少是基于操作系统的分配和调度策略。
* 看看进程怎么说
进程如何看待计算机？ 计算机完全由自己控制的，自己使用了计算机的所有资源。
进程认为整个系统只有自己在运行。如果是32位的，那么我完全占用了4G的内存（虚拟地址空间），如果是64位的，那就是2的64次方的地址空间。实质被操作系统欺骗了。
* 看看操作系统怎么说
	* 操作系统是开心的，因为那位被骗了还不知道。
	* 操作系统是痛苦的，因为有多个进程要骗，所以自己要多维护不少东西。（内核空间）
	* 同时，巧妇难为无米之炊，要骗就要虚拟。 -----虚拟地址空间、虚拟地址。

最后，大家都很满意。都认为自己是胜利者。

#内存的地址#
* 物理地址
* 虚拟地址（逻辑地址）
* 虚拟地址空间

![memoryaddress](/image/memoryaddress.png)
对于计算机来说，开机后操作系统会对物理内存进行初始化，进行分页。这个是对物理内存的操作。
物理地址到逻辑地址的转换需要操作系统和CPU高效的配合。
我们的操作的比如取地址、分配堆 等都是分配多大的虚拟地址空间而不是分配多大的物理内存。用户程序仅仅看到的是虚拟地址。
![maddress](/image/maddress.png)

#一个进程-一个世界#
![processspace](/image/processspace.png)
![vmspace](/image/vmspace.png)
每个进程通过系统调用进入内核，Linux内核空间由系统内的所有进程共享。从进程的角度来看，每个进程拥有4GB的虚拟地址空间。每个进程有各自的私有用户空间（0-3G）,这个空间对系统中的其他进程是不可见的。最高的1GB内核空间则为所有进程以及内核所共享。

程序在执行时，使用一种 paging on demand的方式进行分配内存，产生中断。
例如一个非常大的文件，不可能一次性全部载入的，根据运行过程中的情况去载入。同时，在一定条件下，也会从物理内存中淘汰一些的页。
#课后作业#
<b>1、写时复制的具体含义是什么？</b>
很喜欢老师上课讲的小例子，跟着实验了下体会一把：
编写源文件`vi malloc.c`
```c
#include<stdlib.h>
#include<stdio.h>
int main(void){
 char *ptr;
 while(1){
   ptr=(char *)malloc(1024*1024);
   sleep(1);
 }
 return 0;
}
```
执行 `gcc -o malloc malloc.c`，然后`./malloc`
```bash
[zkn@hadoop1 Desktop]$ ps -ef |grep malloc
zkn       2424  2394  0 00:30 pts/0    00:00:00 ./malloc
zkn       2445  2428  0 00:30 pts/1    00:00:00 grep malloc
[zkn@hadoop1 Desktop]$ top -p 2424
top - 00:34:32 up 11 min,  3 users,  load average: 0.00, 0.13, 0.16
Tasks:   0 total,   0 running,   0 sleeping,   0 stopped,   0 zombie
Cpu(s):  3.1%us,  0.3%sy,  0.0%ni, 96.6%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:   1016516k total,   497376k used,   519140k free,    24768k buffers
Swap:  2064376k total,        0k used,  2064376k free,   219416k cached
PID USER     PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
2424 zkn     20   0 41952  516  300 S  0.0  0.1   0:00.00 malloc 
```
可以看到虚拟地址空间VIRT在不断变化，然后RES物理内存基本没变。
修改程序
```c
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
int main(void){
 char *ptr;
 while(1){
   ptr=(char *)malloc(1024*1024);
   memset(ptr,1,1024*1024);
   sleep(1);
 }
 return 0;
}
```
然后重复上述步骤，可以看到，RES物理内存变化明显加快。

查阅了相关资料：
Linux内核定义了“零页面”（内容全为0的一个物理页，且物理地址固定），应用层的内存分配请求，如栈扩展、堆分配、静态分配等，分配线性地址后，就将页表项条目指向“零页面”（指定初始值的情况除外），这样“零页面”就被所有进程共享，当向页面执行写入操作时，内核就会新分配一个物理页，实行“写时拷贝（写时复制）”操作，这样就实现了物理页面的延迟分配（如果只有读没有写，则无需另分配物理页）。
当系统可分配内存不足时，且有进程要求分配新页面，内核会Kill该进程，并打印类似“Out of Memory: Killed process xx (xxx).”的信息。这就是Linux的“OOM Killer”特性。
	
<b>2、内存物理地址、内存虚拟地址的区别是什么？</b>
虚拟地址空间：在32位的i386 CPU的地址总线的是32位的，也就是说可以寻找到4G的地址空间。我们的程序被CPU执行，就是在0x00000000到0xFFFFFFFF这一段地址中。对于linux来说高1G的空间为内核空间，由操作系统调用，低3G的空间为用户空间，由用户使用。windows是高2G的空间为内核空间，由操作系统调用，低2G的空间为用户空间，由用户使用。
如图所示：
![vmspace](/image/vmspace.png)
 CPU在寻址的时候，是按照虚拟地址来寻址，然后通过MMU(内存管理单元)将虚拟地址转换为物理地址。因为只有程序的一部分加入到内存中，所以会出现所寻找的地址不在内存中的情况（CPU产生缺页异常），如果在内存不足的情况下，就会通过页面调度算法来将内存中的页面置换出来，然后将在外存中的页面加入到内存中，使程序继续正常运行。
![va-pa](/image/va-pa.jpg)
<b>3、操作系统的换页机制是什么？</b>
操作系统将磁盘的一部分划出来，作为虚拟内存，由于内存的速度要比磁盘快得多，所以操作系统要按照某种换页机制将不需要的页面换到磁盘中，将需要的页面调到内存中，这就是换页。也叫系统换页。

之前做的一篇笔记回顾一下[操作系统之虚拟内存管理](http://www.zhaokongnuan.com/2015/01/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)