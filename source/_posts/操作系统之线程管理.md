title: 操作系统之线程管理
date: 2015-01-09 11:15:02
author: 赵空暖
tags: 操作系统
categories: 操作系统
---
> 当你要有很多事要做的时候，但是你又很想玩，你会怎么选择呢，我会一番斗争之后选择先玩，先哭会儿/(ㄒoㄒ)/~~
                                                                   
好了，玩完了，切入正题。
#线程的由来#
自从60年代提出进程概念以来，在操作系统中一直都是以进程作为独立运行的基本单位，直到80年代中期，人们又提出了更小的能独立运行的基本单位线程（thread）。 
##为什么有线程##
【案例】编写一个MP3播放软件。核心功能模块有三个：（1）从MP3音频文件当中读取数据；（2）对数据进行解压缩；（3）把解压缩后的音频数据播放出来。
那先使用前面学过的进程来解决这个问题，单线程的实现方法实现
![thread1](/image/thread1.png)
问题：各个函数之间不是并发执行，影响资源的使用效率；
那么为了实现并发，用多进程的实现方式来试试。
![thread2](/image/thread2.png)
问题：进程之间如何通信，共享数据？另外，维护进程的系统开销较大：创建进程时，分配资源、建立PCB；撤消进程时，回收资源、撤消PCB；进程切换时，保存当前进程的状态信息。还有就是能不能保证播放是连贯的。

怎么来解决这些问题？需要提出一种新的实体，满足以下特性：
（1）实体之间可以并发地执行；
（2）实体之间共享相同的地址空间；
这种实体就是：线程（Thread）

##线程的描述##
线程：进程当中的一条执行流程。
为了弄明白什么是线程，首先重新理解一下进程，从两个方面来理解：
* 从资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台（环境），包括地址空间（代码段、数据段）、打开的文件等各种资源；
* 从运行的角度：代码在这个资源平台上的一条执行流程（即线程）。
![thread3](/image/thread3.png)
所以线程 = 进程 - 共享资源
* 线程的优点：
	* 一个进程中可以同时存在多个线程；
	* 各个线程之间可以并发地执行；
	* 各个线程之间可以共享地址空间和文件等资源。
	![thread4](/image/thread4.png)

这个时候就要思考，线程所占进程提供的资源中，哪些是线程独占的，哪些是线程共享的？ 
![thread6](/image/thread6.png)
* 线程的缺点：
	* 一个线程崩溃，会导致其所属进程的所有线程崩溃
	(因为如果一个线程写错了就可能会破坏和其他线程所共享的资源)
	![thread5](/image/thread5.png)


#线程和进程的比较#
##相同点##
* 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；

##不同点## 
* 进程是资源分配单位，线程是CPU调度单位；
* 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
* 线程能减少并发执行的时间和空间开销：
	* 线程的创建时间比进程短；
	* 线程的终止时间比进程短；
	（小巧矫健嘛~(@^_^@)~）
	* 同一进程内的线程切换时间比进程短；（因为切换进程需要切换页表，不同进程的地址空间是不一样的，而线程是在一个也变上不需要切换页表）
	* 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信；

#线程的实现#
主要有三种线程的实现方式：
* 用户线程：在用户空间实现；（什么是用户空间？像Linux系统将自身划分为两部分，一部分为核心软件，即是kernel，也称作内核空间，另一部分为普通应用程序，这部分称为用户空间。用户空间中的代码运行在较低的特权级别上，只能看到允许它们使用的部分系统资源，并且不能使用某些特定的系统功能，也不能直接访问内核空间和硬件设备，以及其他一些具体的使用限制。）
（POSIX Pthreads，Mach C-threads，Solaris threads）
* 内核线程：在内核中实现；（Windows，Solaris，Linux）
* 轻量级进程：在内核中实现，支持用户线程
Solaris  (LightWeight Process)（Solaris/Linux）每个LWP都与一个特定的内核线程关联，因此每个LWP都是一个独立的线程调度单元。是指线程和进程一对一的关系？官方语言不是很懂o(╯□╰)o。

###用户线程###
在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括进程的创建、终止、同步和调度等。如下图：
![thread7](/image/thread7.png)
* 优点
	* 由于用户线程的维护由相应进程来完成（通过线程库函数），不需要操作系统内核了解用户线程的存在，可用于不支持线程技术的多进程操作系统；
	* 每个进程都需要它自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态信息（PC、栈指针、寄存器），TCB由线程库函数来维护；
	* 用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；
	* 允许每个进程拥有自定义的线程调度算法。
* 缺点
	* 阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；（因为操作系统看不到线程的存在，当一个线程阻塞，操作系统只能将整个进程挂起，这样其它线程也得不到开始，就导致整个进程在等待）
	* 当一个线程开始运行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行（因为线程库函数是用户态没有停止线程的权利，只有操作系统有，如时钟中断）；
	* 由于时间片分配给进程，故与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。

###内核线程###
就是我们操作系统能看见的线程，他的进程控制块也在内核中，由操作系统的内核来完成线程的创建、终止和管理。如下图：
![thread8](/image/thread8.png)
* 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB和TCB）；
* 线程的创建、终止和切换都是通过系统调用/内核函数的方式来进行，由内核来完成，因此系统开销较大；
* 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；
* 时间片分配给线程，多线程的进程获得更多CPU时间；

(图片来源：[清华大学陈瑜老师操作系统公开课](http://www.topu.com/kvideo.php?do=course_progress&kvideoid=4100&classesid=808))


